import os
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from io import StringIO, BytesIO
import base64
from typing import Optional, Dict, Any, List
from dotenv import load_dotenv
import warnings
warnings.filterwarnings('ignore')

from langchain.agents import Tool, AgentExecutor, create_react_agent
from langchain_openai import ChatOpenAI
from langchain.memory import ConversationBufferMemory
from langchain.prompts import PromptTemplate

import streamlit as st

load_dotenv()
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
OPENAI_MODEL = os.getenv("OPENAI_MODEL", "gpt-4")

st.set_page_config(
    page_title="ü§ñ Agente Aut√¥nomo analista de dados",
    page_icon="üìä",
    layout="wide",
    initial_sidebar_state="expanded"
)

class EDAAgent:
    """Agente Aut√¥nomo para An√°lise Explorat√≥ria de Dados"""
    
    def __init__(self, df: pd.DataFrame, api_key: str, model_name: str):
        self.df = df
        self.conclusions = []
        self.analysis_history = []
        self.generated_plots = []
        
        self.llm = ChatOpenAI(
            model=model_name,
            temperature=0,
            openai_api_key=api_key
        )
        
        self.memory = ConversationBufferMemory(
            memory_key="chat_history",
            return_messages=True
        )
        
        self.tools = self._setup_tools()
        
        self.agent = self._setup_agent()

    def _setup_tools(self) -> List[Tool]:
        """Configura as ferramentas dispon√≠veis para o agente"""
        
        tools = [
            Tool(
                name="get_dataframe_info",
                func=self._get_dataframe_info,
                description="Retorna informa√ß√µes b√°sicas sobre o dataframe: colunas, tipos, shape, etc."
            ),
            Tool(
                name="get_statistical_summary",
                func=self._get_statistical_summary,
                description="Retorna resumo estat√≠stico das colunas num√©ricas do dataframe"
            ),
            Tool(
                name="check_missing_values",
                func=self._check_missing_values,
                description="Verifica valores faltantes no dataframe"
            ),
            Tool(
                name="get_correlation_matrix",
                func=self._get_correlation_matrix,
                description="Calcula matriz de correla√ß√£o entre vari√°veis num√©ricas"
            ),
            Tool(
                name="detect_outliers",
                func=self._detect_outliers,
                description="Detecta outliers usando o m√©todo IQR. Input: nome da coluna num√©rica"
            ),
            Tool(
                name="create_histogram",
                func=self._create_histogram,
                description="Cria histograma para uma coluna. Input: nome da coluna"
            ),
            Tool(
                name="create_scatter_plot",
                func=self._create_scatter_plot,
                description="Cria gr√°fico de dispers√£o. Input: 'coluna_x,coluna_y'"
            ),
            Tool(
                name="create_box_plot",
                func=self._create_box_plot,
                description="Cria box plot para uma coluna. Input: nome da coluna"
            ),
            Tool(
                name="add_conclusion",
                func=self._add_conclusion,
                description="Adiciona uma conclus√£o √† an√°lise. Input: texto da conclus√£o"
            )
        ]
        
        return tools

    def _setup_agent(self) -> AgentExecutor:
        """Configura o agente ReAct"""
        
        template = """Responda √† pergunta do usu√°rio da melhor forma poss√≠vel. Voc√™ tem acesso √†s seguintes ferramentas:

{tools}

Use este formato EXATAMENTE:

Question: a pergunta de entrada que voc√™ deve responder
Thought: voc√™ deve sempre pensar sobre o que fazer
Action: a a√ß√£o a tomar, deve ser uma de [{tool_names}]
Action Input: o input da a√ß√£o
Observation: o resultado da a√ß√£o
... (este padr√£o Thought/Action/Action Input/Observation pode repetir)
Thought: Agora eu sei a resposta final
Final Answer: a resposta final √† pergunta original

IMPORTANTE:
- Use NO M√ÅXIMO 3 a√ß√µes por pergunta
- Seja direto e objetivo
- Depois de obter informa√ß√µes suficientes, v√° direto para "Final Answer"
- N√ÉO repita a√ß√µes j√° executadas

Comece agora!

Question: {input}
Thought:{agent_scratchpad}"""

        prompt = PromptTemplate(
            input_variables=["input", "agent_scratchpad", "tools", "tool_names"],
            template=template
        )
        
        agent = create_react_agent(
            llm=self.llm,
            tools=self.tools,
            prompt=prompt
        )
        
        agent_executor = AgentExecutor(
            agent=agent,
            tools=self.tools,
            verbose=True,
            max_iterations=6,
            early_stopping_method="generate",
            handle_parsing_errors=True,
            return_intermediate_steps=True
        )
        
        return agent_executor

    
    def _get_dataframe_info(self, _: str = "") -> str:
        """Retorna informa√ß√µes b√°sicas do dataframe"""
        info = f"""
Informa√ß√µes do Dataset:
- Shape: {self.df.shape[0]} linhas √ó {self.df.shape[1]} colunas
- Colunas: {list(self.df.columns)}
- Tipos de dados: {self.df.dtypes.to_dict()}
- Mem√≥ria usada: {self.df.memory_usage(deep=True).sum() / 1024**2:.2f} MB
"""
        return info

    def _get_statistical_summary(self, _: str = "") -> str:
        """Retorna resumo estat√≠stico"""
        return self.df.describe().to_string()

    def _check_missing_values(self, _: str = "") -> str:
        """Verifica valores faltantes"""
        missing = self.df.isnull().sum()
        missing_pct = (missing / len(self.df)) * 100
        result = pd.DataFrame({
            'Missing Values': missing,
            'Percentage': missing_pct
        })
        result = result[result['Missing Values'] > 0].sort_values('Missing Values', ascending=False)
        
        if len(result) == 0:
            return "N√£o h√° valores faltantes no dataset."
        
        return f"Valores faltantes:\n{result.to_string()}"

    def _get_correlation_matrix(self, _: str = "") -> str:
        """Calcula matriz de correla√ß√£o"""
        numeric_cols = self.df.select_dtypes(include=[np.number]).columns
        
        if len(numeric_cols) < 2:
            return "N√£o h√° colunas num√©ricas suficientes para calcular correla√ß√µes."
        
        corr_matrix = self.df[numeric_cols].corr()
        return f"Matriz de Correla√ß√£o:\n{corr_matrix.to_string()}"

    def _detect_outliers(self, column: str) -> str:
        """Detecta outliers usando IQR"""
        column = column.strip()
        
        if column not in self.df.columns:
            return f"Coluna '{column}' n√£o encontrada."
        
        if not pd.api.types.is_numeric_dtype(self.df[column]):
            return f"Coluna '{column}' n√£o √© num√©rica."
        
        Q1 = self.df[column].quantile(0.25)
        Q3 = self.df[column].quantile(0.75)
        IQR = Q3 - Q1
        
        lower_bound = Q1 - 1.5 * IQR
        upper_bound = Q3 + 1.5 * IQR
        
        outliers = self.df[(self.df[column] < lower_bound) | (self.df[column] > upper_bound)]
        
        return f"""
An√°lise de Outliers para '{column}':
- Q1: {Q1:.2f}
- Q3: {Q3:.2f}
- IQR: {IQR:.2f}
- Limite inferior: {lower_bound:.2f}
- Limite superior: {upper_bound:.2f}
- N√∫mero de outliers: {len(outliers)} ({len(outliers)/len(self.df)*100:.2f}%)
"""

    def _create_histogram(self, column: str) -> str:
        """Cria histograma"""
        column = column.strip()
        
        if column not in self.df.columns:
            return f"Coluna '{column}' n√£o encontrada."
        
        fig, ax = plt.subplots(figsize=(10, 6))
        self.df[column].hist(bins=30, ax=ax, edgecolor='black')
        ax.set_title(f'Histograma: {column}')
        ax.set_xlabel(column)
        ax.set_ylabel('Frequ√™ncia')
        plt.tight_layout()
        
        buf = BytesIO()
        plt.savefig(buf, format='png', dpi=100, bbox_inches='tight')
        buf.seek(0)
        img_base64 = base64.b64encode(buf.read()).decode()
        plt.close()
        
        self.generated_plots.append({
            'type': 'histogram',
            'column': column,
            'image': img_base64
        })
        
        return f"Histograma criado para a coluna '{column}'"

    def _create_scatter_plot(self, columns: str) -> str:
        """Cria gr√°fico de dispers√£o"""
        try:
            col_x, col_y = [c.strip() for c in columns.split(',')]
        except:
            return "Formato inv√°lido. Use: 'coluna_x,coluna_y'"
        
        if col_x not in self.df.columns or col_y not in self.df.columns:
            return f"Uma ou ambas as colunas n√£o foram encontradas."
        
        fig, ax = plt.subplots(figsize=(10, 6))
        ax.scatter(self.df[col_x], self.df[col_y], alpha=0.5)
        ax.set_xlabel(col_x)
        ax.set_ylabel(col_y)
        ax.set_title(f'Scatter Plot: {col_x} vs {col_y}')
        plt.tight_layout()
        
        buf = BytesIO()
        plt.savefig(buf, format='png', dpi=100, bbox_inches='tight')
        buf.seek(0)
        img_base64 = base64.b64encode(buf.read()).decode()
        plt.close()
        
        self.generated_plots.append({
            'type': 'scatter',
            'columns': f"{col_x} vs {col_y}",
            'image': img_base64
        })
        
        return f"Scatter plot criado para '{col_x}' vs '{col_y}'"

    def _create_box_plot(self, column: str) -> str:
        """Cria box plot"""
        column = column.strip()
        
        if column not in self.df.columns:
            return f"Coluna '{column}' n√£o encontrada."
        
        fig, ax = plt.subplots(figsize=(10, 6))
        self.df.boxplot(column=[column], ax=ax)
        ax.set_title(f'Box Plot: {column}')
        ax.set_ylabel(column)
        plt.tight_layout()
        
        buf = BytesIO()
        plt.savefig(buf, format='png', dpi=100, bbox_inches='tight')
        buf.seek(0)
        img_base64 = base64.b64encode(buf.read()).decode()
        plt.close()
        
        self.generated_plots.append({
            'type': 'boxplot',
            'column': column,
            'image': img_base64
        })
        
        return f"Box plot criado para a coluna '{column}'"

    def _add_conclusion(self, conclusion: str) -> str:
        """Adiciona conclus√£o"""
        self.conclusions.append(conclusion)
        return f"Conclus√£o adicionada: {conclusion}"

    def analyze(self, query: str) -> Dict[str, Any]:
        """Executa an√°lise baseada na query"""
        
        simple_response = self._try_simple_answer(query)
        if simple_response:
            return {
                'success': True,
                'response': simple_response,
                'plots': self.generated_plots.copy(),
                'conclusions': self.conclusions.copy()
            }
        
        try:
            response = self.agent.invoke({"input": query})
            
            output = response.get('output', '')
            
            if not output and 'intermediate_steps' in response:
                steps = response['intermediate_steps']
                if steps:
                    last_observation = steps[-1][1] if len(steps[-1]) > 1 else ""
                    output = f"An√°lise parcial baseada nas ferramentas executadas:\n\n{last_observation}"
            
            result = {
                'success': True,
                'response': output if output else "N√£o foi poss√≠vel gerar uma resposta completa.",
                'plots': self.generated_plots.copy(),
                'conclusions': self.conclusions.copy()
            }
            
            self.generated_plots.clear()
            
            return result
            
        except Exception as e:
            plots = self.generated_plots.copy()
            self.generated_plots.clear()
            
            error_msg = str(e)
            
            if "iteration limit" in error_msg.lower() or "time limit" in error_msg.lower():
                return {
                    'success': True,
                    'response': "Executei algumas an√°lises mas n√£o consegui completar totalmente. Aqui est√£o os resultados parciais:",
                    'plots': plots,
                    'conclusions': self.conclusions.copy()
                }
            
            return {
                'success': False,
                'error': error_msg,
                'plots': plots,
                'conclusions': []
            }
    
    def _try_simple_answer(self, query: str) -> Optional[str]:
        """Tenta responder perguntas simples sem usar o agente"""
        query_lower = query.lower()
        
        if any(word in query_lower for word in ['colunas', 'columns', 'vari√°veis', 'variables']):
            if 'quantas' in query_lower or 'n√∫mero' in query_lower or 'how many' in query_lower:
                return f"O dataset possui {len(self.df.columns)} colunas: {', '.join(self.df.columns)}"
        
        if any(word in query_lower for word in ['linhas', 'rows', 'registros', 'records']):
            if 'quantas' in query_lower or 'quantos' in query_lower or 'how many' in query_lower:
                return f"O dataset possui {len(self.df)} linhas (registros)."
        
        if 'shape' in query_lower or 'tamanho' in query_lower or 'dimens√£o' in query_lower:
            return f"O dataset tem {self.df.shape[0]} linhas e {self.df.shape[1]} colunas."
        
        if 'primeiras' in query_lower or 'head' in query_lower:
            return f"Primeiras linhas do dataset:\n\n{self.df.head().to_string()}"
        
        return None


def main():
    """Interface principal do Streamlit"""
    
    st.title("ü§ñ Agente Aut√¥nomo de EDA")
    st.markdown("### An√°lise Explorat√≥ria de Dados com Intelig√™ncia Artificial")
    st.markdown("---")
    
    with st.sidebar:
        st.header("‚öôÔ∏è Configura√ß√µes")

        if not OPENAI_API_KEY:
            st.error("‚ùå A vari√°vel `OPENAI_API_KEY` n√£o foi encontrada no arquivo .env.")
        else:
            st.success("‚úÖ API Key carregada do .env")

        st.markdown(f"**Modelo:** `{OPENAI_MODEL}`")

        st.markdown("---")
        
        st.header("üìÅ Upload do CSV")
        uploaded_file = st.file_uploader(
            "Escolha um arquivo CSV",
            type=['csv'],
            help="Fa√ßa upload do arquivo CSV para an√°lise"
        )
        
        st.markdown("---")
        st.header("‚ÑπÔ∏è Sobre")
        st.markdown("""
        Este agente aut√¥nomo pode:
        - ‚úÖ Analisar dados
        - üìä Criar visualiza√ß√µes
        - üîç Detectar anomalias
        - üîó Encontrar correla√ß√µes
        - üìù Gerar conclus√µes
        """)

    if not OPENAI_API_KEY:
        st.stop()
    
    if not uploaded_file:
        st.info("üìÅ Por favor, fa√ßa upload de um arquivo CSV na barra lateral para come√ßar")
        return
    
    try:
        df = pd.read_csv(uploaded_file)
        st.success(f"‚úÖ Arquivo carregado: {uploaded_file.name}")
        
        with st.expander("üëÄ Preview dos Dados", expanded=False):
            st.dataframe(df.head(10))
            st.write(f"**Shape:** {df.shape[0]} linhas √ó {df.shape[1]} colunas")
        
    except Exception as e:
        st.error(f"‚ùå Erro ao carregar arquivo: {str(e)}")
        return
    
    if 'agent' not in st.session_state or st.session_state.get('current_file') != uploaded_file.name:
        with st.spinner("ü§ñ Inicializando agente..."):
            st.session_state.agent = EDAAgent(df, OPENAI_API_KEY, OPENAI_MODEL)
            st.session_state.current_file = uploaded_file.name
            st.session_state.messages = []
    
    agent = st.session_state.agent
    
    st.header("üí¨ Chat com o Agente")
    
    for message in st.session_state.messages:
        with st.chat_message(message["role"]):
            st.markdown(message["content"])
            
            if "plots" in message and message["plots"]:
                for plot in message["plots"]:
                    st.image(f"data:image/png;base64,{plot['image']}")
    
    if prompt := st.chat_input("Fa√ßa uma pergunta sobre os dados..."):
        st.session_state.messages.append({"role": "user", "content": prompt})
        
        with st.chat_message("user"):
            st.markdown(prompt)
        
        with st.chat_message("assistant"):
            with st.spinner("ü§î Analisando..."):
                result = agent.analyze(prompt)
                
                if result['success']:
                    st.markdown(result['response'])
                    
                    if result['plots']:
                        for plot in result['plots']:
                            st.image(f"data:image/png;base64,{plot['image']}")
                    
                    st.session_state.messages.append({
                        "role": "assistant",
                        "content": result['response'],
                        "plots": result['plots']
                    })
                else:
                    error_msg = f"‚ùå Erro: {result['error']}"
                    st.error(error_msg)
                    st.session_state.messages.append({
                        "role": "assistant",
                        "content": error_msg
                    })
    
    if st.sidebar.button("üóëÔ∏è Limpar Conversa"):
        st.session_state.messages = []
        st.rerun()

if __name__ == "__main__":
    main()